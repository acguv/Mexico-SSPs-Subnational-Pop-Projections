---
title: "CDM Multi-State Population Projection Model"
output:
  html_document:
    df_print: paged
---

# Packages
```{r, R.options = options(readr.show_progress = F)}

# Tidyverse and data.table for data wrangling
if (!requireNamespace("tidyverse", quietly = T))  install.packages('tidyverse')
if (!requireNamespace("data.table", quietly = T)) install.packages('data.table')

library(tidyverse)
library(data.table)


# Load the ancillary functions
ancillary_functions <- file.path('scripts', 'R', 'ancillary_functions')

for (cur_file in list.files(ancillary_functions, full.names = T)) 
  source(cur_file)

```


# Input Data
Here we set some input parameters for the model. These inputs are:

* Country for which we are going to do sub-national projections
* Two UN life tables to adjust scenario-based mortality estimates
* A factor indicating whether or not internal migrations is applied
* A factor indicating whether or not international migrations is applied
* Current scenario
* Base year of projections
* Last year of projections
* Number of age groups

```{r}
# Inputs and Paths 

# Path to state-level inputs folder
cur_country <- "Mexico"
inputs_path  <- file.path('inputs')
outputs_path <- file.path('outputs')


# UN standard life table e0=30; used for linear interpolation of lx values
un_mortality_30_path <- file.path(inputs_path, 'AllRegions_mortality_UNe030.csv') 


# UN standard life table e0=100; used for linear interpolation of lx values
un_mortality_100_path <- file.path(inputs_path, 'AllRegions_mortality_UNe0100.csv')


# Specify regions
regions <- list.dirs(inputs_path, recursive = F, full.names = F)


# Specify scenario
cur_scenario <- 'constant_rates_ent'


# Enter time and age related parameters
start_year      <- 2020               
end_year        <- 2100                
steps           <- end_year - start_year 
num_ages        <- 101
intl_mig_factor <- 1 
int_mig_factor  <- 1 


# Path to results folder 
results_path <- file.path(outputs_path, cur_scenario)

if (!dir.exists(results_path)) {
  
  dir.create(results_path)
} else {
  
  print('The results folder already exists!')
}
```


# Main Program

List all regions. In this case, Mexico's states.

```{r}
# Specify regions
regions <- list.dirs(inputs_path, recursive = F, full.names = F)
print(regions)
```

## Base year population
We first create a data frame that will store population outcomes for all states.

```{r}
upd_all_base_pop <- data.frame(matrix(0, nrow = 4 * num_ages, ncol = length(regions)))
colnames(upd_all_base_pop) <- regions
print(head(upd_all_base_pop))
```


In this section, we update the base year population with migration.
We use the state of **Baja California** as an example.

```{r, echo=FALSE}
cur_region <- regions[2]
print(str_c('region = ', cur_region))
```

We apply the **base_pop_summarizer** function, which generates a list of three
outputs. They are:

* Age and gender-specific initial population in the base year (ini_pop_df) 
* Age and gender-specific international migrants in the base year (cur_int_mig)
* Age and gender-specific updated population by international migrants in the base year (upd_pop_df)
```{r}
base_pop <- base_pop_summarizer(cur_region, inputsPath, yearStart, num_ages,
                                int_mig, cur_scenario)
```


```{r}
# Base year population without applying international migration
ini_pop_df <- base_pop$ini_pop
print(head(ini_pop_df, 15))

```

```{r}
# Base year international migration
cur_int_mig <- base_pop$int_mig
print(head(cur_int_mig, 15))
```


```{r}
# Base year population after applying international migration
upd_pop_df   <- base_pop$upd_pop
print(head(upd_pop_df, 15))
```

Now that we saw how the function works for a single state, we apply it to all 
states.
```{r}
# Update states base year population with international and state-level migrations
for (cur_region in regions){
  
  # Estimate base population elements
  base_pop    <- base_pop_summarizer(cur_region, inputsPath, yearStart, num_ages,
                                     int_mig, cur_scenario)
  
  # Base year population without applying international migration
  ini_pop_df  <- base_pop$ini_pop 
  
  # Base year population after applying international migration
  upd_pop_df   <- base_pop$upd_pop
  
  # Base year international migration
  cur_int_mig <- base_pop$int_mig
  
  
  # Populate the resulting data-frame 
  upd_all_base_pop[, cur_region] <- upd_pop_df

}

upd_all_base_pop[is.na(upd_all_base_pop)] <- 0
```


Age and gender specific population of all states updated by international migration.
```{r}
upd_all_base_pop
```

After populations of all states are updated by international migration, we apply
internal migration. We apply internal migration using calculations on bilateral 
internal migration rates. The functions below produce a list of two outputs:

* Internal in and out migration for each state
* Internal in and out migration between pairs of states

```{r}
# Calculate the total in out and net migration numbers for all states
in_migration  <- f.in.dom.mig.calc(inputsPath, upd_all_base_pop, cur_scenario,
                                   yearStart, scen_factor)

out_migration <- f.out.dom.mig.calc(inputsPath, upd_all_base_pop, cur_scenario,
                                    yearStart, scen_factor)

```


The number of age and gender specific internal migrants to each state.
```{r}
print(head(in_migration$total_inmigration), 5)
```

The number of age and gender specific internal migrants from each state.
```{r}
print(head(out_migration$total_outmigration), 5)
```

Derive net migration.
```{r}
net_migration <- in_migration$total_inmigration - out_migration$total_outmigration

print(head(net_migration))
```

The sum of internal migration should be 0 or very close to it.
```{r}
print(sum(net_migration))
```


The functions also calculate the number of migrants between states. Below is the 
example for Baja California.
```{r}
print(head(in_migration$state_pair_inmigration$`02-BCN`), 5)
```

```{r}
print(head(out_migration$state_pair_outmigration$`02-BCN`), 5)
```

We can save migrations between pairs of states for future visualizations.
```{r, echo=FALSE}
tot_in_migration_list  <- vector(mode = "list", length = steps + 1)
tot_out_migration_list <- vector(mode = "list", length = steps + 1)

tot_in_migration_list[[1]]  <- out_migration$state_pair_inmigration
tot_out_migration_list[[1]] <- out_migration$state_pair_outmigration
```


Finally, we update the base year population with internal migration.
```{r}
upd_all_base_pop <- upd_all_base_pop + as.data.frame(net_migration)
```


# Mortality
Mortality estimation based on the scenario for all states. They are derived for
age, gender and each projection year (0:2015, 85:2100).
Three important outputs are:

* tot_survival_df: survival ratios 
* tot_lx_df: Number of individuals surviving to the beginning of a given age interval
* tot_Lx_df: Person-years lived by the cohort within a particular age interval 
```{r}
mortality <- mortality_estimator(regions, inputsPath, cur_scenario, yearStart, yearEnd,
                                 datMortS30, datMortS100)


# Mortality variables for all states and years
tot_survival_df <- mortality$tot_dfSx
tot_lx_df       <- mortality$tot_dflx
tot_Lx_df       <- mortality$tot_dfLx
```
```{r}
print(dim(tot_survival_df))
```


```{r}
print(head(tot_survival_df, 5))
```

```{r}
print(head(tot_lx_df, 5))
```

```{r}
print(head(tot_Lx_df, 5))
```


Scenario-based age-specific Fertility rates for all states for each projection year (0:2015, 85:2100).
```{r}
tot_fert_df <- fertility_estimator(regions, inputsPath, cur_scenario, yearStart,
                                   yearEnd, use_brass = T)
```
```{r}
print(dim(tot_fert_df))
```

```{r}
print(head(tot_fert_df, 20))
```


# Population Projection
```{r}
t <- 1
print(paste("Current Year is", yearStart + t))
```

We first initialize the projection results data-frame for the current year
```{r}
pop_projections_df <- data.frame(matrix(0, nrow = nrow(upd_all_base_pop), 
                                           ncol = length(regions)))

colnames(pop_projections_df) <- regions

head(pop_projections_df)
```


Read the scenario file for the current state.
```{r}
cur_region <- '03-BCS'
region_num <- which(regions == cur_region)

pathIn <- file.path(inputsPath, regions[region_num])


# Scenario data
scenario_df <- file.path(pathIn, paste0(cur_scenario, ".csv")) %>%
  read.csv(check.names = F, stringsAsFactors = F)  

print(head(scenario_df))
```


Using the scenario-informed sexual ratio at birth, we derive proportions of males
and females. Currently, there is no differentiation between urban and rural.

```{r}
# Note: This generates a data frame with a "year" and "sr" column
srDf1U <- data.frame(year = 0:steps, sr = scenario_df$sr_U) # urban
srDf1R <- data.frame(year = 0:steps, sr = scenario_df$sr_R) # rural


# Compute Proportion male and females at birth according to the scenario
# Urban
srDf1U$propM <- (srDf1U$sr / 100) / (1 + (srDf1U$sr / 100))
srDf1U$propF <- 1 - srDf1U$propM

# Rural
srDf1R$propM <- (srDf1R$sr / 100) / (1 + (srDf1R$sr / 100))
srDf1R$propF <- 1 - srDf1R$propM
```

```{r}
print(head(srDf1U))
```


Extract the fertility, survival ratio, lx, and LX (life table components) data-frames for the current state. 0 means 2015, 1 means 2016, etc. F:Females, M:Males 
U: Urban, R: Rural
```{r}
fertility_df <- tot_fert_df[seq(1 + (region_num - 1) * num_ages, region_num * num_ages), ]
survival_df  <- tot_survival_df[seq(1 + (region_num - 1) * num_ages, region_num * num_ages), ]
lx_df        <- tot_lx_df[seq(1 + (region_num - 1) * num_ages, region_num * num_ages), ]
Lx_df        <- tot_Lx_df[seq(1 + (region_num - 1) * num_ages, region_num * num_ages), ]

print(head(survival_df))
```

Derive female and male birth rates. This is derived by sex ratio, survival values and
fertility rates.
```{r}
mBxF <- f.lBx2(fertility_df, srDf1R, srDf1U, Lx_df, lx_df, survival_df, t, "F")  
mBxM <- f.lBx2(fertility_df, srDf1R, srDf1U, Lx_df, lx_df, survival_df, t, "M") 
```



```{r}
# Generate transition matrix
# Diagonal matrix pieces of Survival
# Note: for the matrix computation step of the projection it is necessary that the transition matrix is quadratic
# in this case it is necessary to add two "0" value columns to account for the merge of the Bx and Sx matrices
# use bdiag() function from Matrix package to construct a block diagonal matrix
mSxFd <- cbind(diag(c(rbind(survival_df[1:(num_ages-1), str_c("SxFU", t-1)],
                            survival_df[1:(num_ages-1), str_c("SxFR", t-1)])), 
                    2*(num_ages-1), 2 * (num_ages-1)), 0, 0)

mSxMd <- cbind(diag(c(rbind(survival_df[1:(num_ages-1), str_c("SxMU", t-1)],
                            survival_df[1:(num_ages-1), str_c("SxMR", t-1)])), 
                    2*(num_ages-1), 2 * (num_ages-1)), 0, 0)


# Horizontal matrix pieces of Birth rates
mBxFd <- mBxF$Bx2   # females
mBxMd <- mBxM$Bx2   # males



# Generate quadrant pieces of transition matrix
# female births + female survival
mat11 <- rbind(mBxFd, mSxFd)   
# no values
mat12 <- matrix(0, nrow = nrow(mat11), ncol = ncol(mat11))
# male births -> the new born boys are now computed based on the population of reproductive females
mat21 <- rbind(mBxMd, matrix(0, nrow = (nrow(mat11) - nrow(mBxMd)), ncol = ncol(mat11))) 
# male survival
mat22 <- rbind(matrix(0, nrow = (nrow(mat11) - nrow(mSxMd)), ncol = ncol(mat11)), mSxMd) 


# Combine quadrant pieces to complete matrix
transition_matrix <- rbind(cbind(mat11, mat12), cbind(mat21, mat22))
transition_matrix[is.na(transition_matrix)]       <- 0 # re-code all "NaN" values to 0
transition_matrix[is.infinite(transition_matrix)] <- 0 # re-codes all Inf and -Inf values to 0


pop_projections_df[, cur_region] <- transition_matrix%*%as.matrix(upd_all_base_pop[, cur_region])
```


This is the population projection in 2016 for **Baja California** after applying fertility, mortality and migration.
```{r}
head(pop_projections_df)
```


